0.  It s a contrived word created in 1935 by the president of the National Puzzler's League that is recognized as the longest word in the English language. According to the Oxford dictionary, the word describes a lung disease caused by inhaling very fine ash and sand dust.
1.  getrusage() returns resource usage statistics for the calling process.
2.  16
3.  For one, there is a benefit in not having to create new variables. Also, calculate() could have the wrong values if the value for before and after are modified outside of the function. By passing reference instead of value, calculate() always has access to the latest variable data.
4.  main() first ensures that the right number of arguments are used, calls getrusage() and calculate() to measure load times before and after. If there is a specified dictionary file it loads what was passed in that argument, otherwise it loads the default file specified in #define DICTIONARY. Then it creates a string array word, set to the length in the #define statement plus one char for the \0 byte. The main for loop reads the file one character at a time, until reaching end of file (EOF). For each character, the loop checks if the char is alphanumeric or an apostrophe, then updates the index and moves on to the next letter. The loop also checks if the char is a number and if so ignores it. If the loop reaches '\0' and the index is still smaller than the length of the longest word plus one extra byte, and it did not contain any numbers, the loop assumes it is a real word, updates the variable containing the number of words, calls getrusage() again and executes the misspelled function. If misspelled returns true, the main for loop prints the misspelled word, updates the variable containing the number of misspelled words found, and sets the index back to 0 and returns to the start of the loop for the next word.
5.  Using fscanf is a good option if you are confident that the input data is well-structured text, but can cause problems with alphanumeric strings or texts containing formatting errors. By using fgetc, we can read one character at a time and ensure that it is a letter or apostrophe and thus likely to be part of a word.  
6.  Declaring "const char*" creates a mutable pointer to an immutable char. By using const char*, if you accidentally try to change the value it points to, the compiler would give a warning. Since the words from the text and the dictionary are not supposed to be manipulated in this solution, it is safer to declare a const.
7. I used a trie to create a structure with 27 child nodes, one for each lowercase letter from a to z, and one for the apostrophes. 
8. Once I got my implementation to compile and run, the speed has only marginally improved with the various changes I’ve made. However, I didn’t run check50 until very late in the process and realized that my code wasn’t handling apostrophes or alphanumeric words correctly.
9. I started off trying to implement a hash table, but was having too many problems. After reading more about trie structures (especially this page: http://simplestcodings.blogspot.com/2012/11/trie-implementation-in-c.html) I implemented the trie for this solution.
10. I think the code is about as good as I’m able to make it without any major changes. From everything I’ve read, it seems that this type of trie solution is the best way to handle this problem. Also, it’s hard to know since the benchmarking is not perfect. Running the same text through the same dictionary on the same computer I’ve seen my time go up or down by as much as 20-40 percent. There may very well be small incremental changes I could make, but it would be hard to A/B test their effectiveness given the range of times I’ve seen.
